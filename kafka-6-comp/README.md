# Проект-доказательство понимания Главы 6 Kafka

Доказательство изучения: "Kafka: The Definitive Guide" (2-е издание), Глава 6.

## Цель
Показать понимание внутренних механизмов Kafka через теорию, термины и мини-демонстрации, покрывающие ключевые разделы главы.

## Структура

```
kafka-6-comp/
├── README.md
├── report.txt
├── docker-compose.yml
├── scripts/
│   ├── demo-isr.sh
│   ├── demo-leader-election.sh
│   ├── demo-log-structure.sh
│   ├── demo-controller.sh
│   └── demo-requests.sh
└── java/
	├── RequestFlowDemo.java
	└── AcksLatencyNotes.java
```

## Соответствие разделам Главы 6

1. Членство в кластере и метаданные: ZooKeeper/KRaft, эфемерные узлы, обнаружение отказов
2. Контроллер: выбор лидеров, обновление метаданных, epochs
3. Репликация: leader/follower, ISR, high watermark
4. Обработка запросов: network/IO threads, purgatory, produce/fetch
5. Физическое хранение: сегменты, индексы, компактизация, retention
6. Будущие механизмы: tiered storage, KRaft

## Факты и термины по разделам

### Членство в кластере
- Брокеры регистрируются в ZooKeeper (или в KRaft-метаданных) через эфемерные узлы.
- Потеря сессии приводит к исчезновению узла и перераспределению ролей.
- Метаданные нужны для маршрутизации produce/fetch запросов.

### Контроллер
- Один брокер действует как контроллер.
- Контроллер управляет выборами лидеров партиций.
- Controller epoch защищает от "зомби"-контроллера.

### Репликация и ISR
- Leader принимает запись и чтение.
- Followers реплицируют лог лидера.
- ISR содержит реплики без критичного отставания.
- High watermark определяет максимальный offset, видимый потребителям.

### Обработка запросов
- Acceptor принимает соединения.
- Processor читает запросы и кладет в очереди.
- IO threads выполняют операции и возвращают ответы.
- Purgatory удерживает запросы, пока не выполнены условия acks.

### Физическое хранение
- Данные пишутся в сегменты логов.
- `.index` ускоряет поиск по offset.
- `.timeindex` ускоряет поиск по времени.
- Компактизация сохраняет последнее значение по ключу.

### KRaft и tiered storage
- KRaft устраняет зависимость от ZooKeeper.
- Tiered storage переносит старые сегменты в объектное хранилище.

## Демонстрации и теория

### Demo 1: Динамика ISR
Файл: `scripts/demo-isr.sh`

Теория: ISR — динамический набор реплик. Исключение из ISR происходит по времени отставания, а не по числу сообщений. Это влияет на acks=all и доступность.

### Demo 2: Выбор лидера
Файл: `scripts/demo-leader-election.sh`

Теория: Лидер выбирается из ISR. Контроллер инициирует выборы и повышает epoch, предотвращая split-brain.

### Demo 3: Контроллер и метаданные
Файл: `scripts/demo-controller.sh`

Теория: Контроллер хранит метаданные о лидерах партиций. ZooKeeper содержит node `/controller`, который отражает текущего контроллера.

### Demo 4: Produce/Fetch запросы
Файл: `scripts/demo-requests.sh`

Теория: Produce записывает данные в лог лидера, Fetch читает по offset. При acks=all produce ждет подтверждения всех ISR.

### Demo 5: Структура логов
Файл: `scripts/demo-log-structure.sh`

Теория: Сегменты логов неизменяемы после закрытия; индексы ускоряют доступ. Это повышает эффективность репликации и кэширования.

## Код и теория

### RequestFlowDemo.java
Объясняет цепочку обработки запросов (Acceptor → Processor → IO → Purgatory) и влияние acks на надежность и latency.

### AcksLatencyNotes.java
Фиксирует смысл уровней acks и связь с ISR и high watermark.

## Теоретические вопросы и ответы

1. Почему Kafka использует pull-модель?
Ответ: Она дает контроль скорости чтения, поддерживает батчи и не перегружает медленных потребителей.

2. Что происходит при потере всех ISR?
Ответ: Партиция недоступна для записи (если unclean election выключен). При включении возможна потеря данных.

3. Как Kafka достигает exactly-once?
Ответ: Идемпотентные продюсеры + транзакции обеспечивают отсутствие дубликатов и атомарность.

4. Зачем нужен high watermark?
Ответ: Он определяет последнюю запись, подтвержденную всеми ISR; потребители видят только данные до HW.

5. Чем KRaft лучше ZooKeeper?
Ответ: Убирает внешнюю зависимость, масштабируется лучше и ускоряет операции с метаданными.

6. В чем разница leader epoch и controller epoch?
Ответ: Leader epoch меняется при смене лидера партиции, controller epoch — при смене контроллера.

7. Почему компактизация полезна?
Ответ: Она сохраняет последнее значение по ключу — удобно для changelog и восстановления состояния.

8. Почему Kafka удаляет целые сегменты?
Ответ: Это быстрый и безопасный способ очистки без фрагментации и сложной переработки логов.

9. Что такое replica fetcher lag?
Ответ: Отставание LEO фолловера от лидера. При превышении времени отставания реплика исключается из ISR.

10. Почему Kafka активно использует батчи?
Ответ: Диск, сеть и компрессия выигрывают от крупных блоков, снижая накладные расходы.

## Как запустить демонстрации

```bash
docker-compose up -d
./scripts/demo-isr.sh
./scripts/demo-leader-election.sh
./scripts/demo-controller.sh
./scripts/demo-requests.sh
./scripts/demo-log-structure.sh
```

## Итог
Проект покрывает ключевые механизмы главы: членство в кластере, контроллер, репликация, обработка запросов и хранение. Демонстрации и ответы на вопросы показывают понимание причин и последствий настроек.
